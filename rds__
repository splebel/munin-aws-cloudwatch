#!/usr/bin/env ruby
require 'rubygems'
require 'AWS'

dbinstance = File.basename(__FILE__).scan(/(?<=rds_).*(?=_)/).first
metricname = File.basename(__FILE__).scan(/(?<=_)[a-z]*$/).first

dimensions = "DBInstanceIdentifier=#{dbinstance}"
namespace = 'AWS/RDS'

timeperiod = 300

if dbinstance.empty?
  puts 'Cannot read db instance name'
  exit 1
end

if metricname.empty?
  puts 'Cannot read metric name'
  exit 1
end

case metricname
when 'cpu'
  metricname = 'CPUUtilization'
  graphtitle = 'CPU Usage'
  graphbase = 1000
  graphvlabel = '%'
  graphcategory = 'System'
  graphinfo = 'This graph shows the CPU utilization of the RDS instance'
when 'connections'
  metricname = 'DatabaseConnections'
  graphtitle = 'Connections'
  graphbase = 1000
  graphvlabel = 'Number of connections'
  graphcategory = 'RDS'
  graphinfo = 'Number of incoming connections to the database instance'
when 'mem'
  metricname = 'FreeableMemory'
  graphtitle = 'Freeable Memory'
  graphbase = 1024
  graphvlabel = 'Memory in Bytes'
  graphcategory = 'System'
  graphinfo = 'Available memory to the database instance'
when 'freespace'
  metricname = 'FreeStorageSpace'
  graphtitle = 'Storage Free'
  graphbase = 1024
  graphvlabel = 'Storage space in bytes'
  graphcategory = 'Disk'
  graphinfo = 'This graph shows the Amount of free space left on the database instance'
when 'readiops'
  metricname = 'ReadIOPS'
  graphtitle = 'Read IOPS'
  graphbase = 1000
  graphvlabel = 'Reads per second'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows the number of Read IOPS on the database instance'
when 'readlatency'
  metricname = 'ReadLatency'
  graphtitle = 'Read Latency'
  graphbase = 1000
  graphvlabel = 'Read Latency in seconds'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows the amount of latency on reads'
when 'readthroughput'
  metricname = 'ReadThroughput'
  graphtitle = 'Read Throughput'
  graphbase = 1024
  graphvlabel = 'Throughput in bytes / second'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows read throughput in bytes per second'
when 'swap'
  metricname = 'SwapUsage'
  graphtitle = 'Swap Usage'
  graphbase = 1024
  graphvlabel = 'Swap usage in bytes'
  graphcategory = 'System'
  graphinfo = 'This graph shows the amount of swapfie used by the database instance'
when 'writeiops'
  metricname = 'WriteIOPS'
  graphtitle = 'Write IOPS'
  graphbase = 1000
  graphvlabel = 'Writes per second'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows the number of Write IOPS on the database instance'
when 'writelatency'
  metricname = 'WriteLatency'
  graphtitle = 'Write Latency'
  graphbase = 1000
  graphvlabel = 'Write Latency in seconds'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows the amount of latency on Writes'
when 'writethroughput'
  metricname = 'WriteThroughput'
  graphtitle = 'Write Throughput'
  graphbase = '1024'
  graphvlabel = 'Throughput in bytes / second'
  graphcategory = 'RDS'
  graphinfo = 'This graph shows Write throughput in bytes per second'
else
  puts 'Unknown metric'
  exit 1
end

if ARGV.first == 'config'
  puts "host_name #{dbinstance}"
  puts "graph_title #{graphtitle}"
  puts "graph_args --base #{graphbase} -l 0"
  puts "graph_vlabel #{graphvlabel}"
  puts "graph_category #{graphcategory}"
  puts "graph_info #{graphinfo}"
  puts 'average.draw LINE2'
  puts 'average.label average'
  puts 'min.draw LINE2'
  puts 'min.label minimum'
  puts 'max.draw LINE2'
  puts 'max.label maximum'
  exit 0
end

if ENV['AWS_ACCESS_KEY_ID'].nil?
  puts 'AWS ID not specified. Set env.AWS_ACCESS_KEY_ID'
  exit 1
else
  access_key_id = ENV['AWS_ACCESS_KEY_ID']
end

if ENV['AWS_SECRET_ACCESS_KEY'].nil?
  puts 'AWS Secret not specified. Set env.AWS_SECRET_ACCESS_KEY'
  exit 1
else
  secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']
end

begin
  cw = AWS::Cloudwatch::Base.new(:access_key_id => access_key_id, :secret_access_key => secret_access_key)
rescue Exception => e
  puts 'Unknown Exception:', e.inspect
  exit 3
end

res = cw.get_metric_statistics(:namespace => namespace, :measure_name => metricname, :statistics => "Average,Minimum,Maximum", :dimensions => dimensions, :period => timeperiod, :start_time => (Time.now() - timeperiod) )

avg = res['GetMetricStatisticsResult']['Datapoints']['member'].first['Average']
min = res['GetMetricStatisticsResult']['Datapoints']['member'].first['Minimum']
max = res['GetMetricStatisticsResult']['Datapoints']['member'].first['Maximum']

puts "average.value #{avg}"
puts "min.value #{min}"
puts "max.value #{max}"

exit 0
